题目链接：https://www.luogu.com.cn/problem/P1048

题目描述
辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

输入格式
第一行有 2 个整数 T（1 <= T <= 10000）和 M（1≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。

接下来的 M 行每行包括两个在 1-100 之间（包括1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

输出格式
输出在规定的时间内可以采到的草药的最大总价值。

输入输出样例
输入 #1复制
70 3
71 100
69 1
1 2
输出 #1复制
3
说明/提示
对于 %30 的数据，M≤10；
对于全部的数据，M≤100。

>害，此题是典型的0——1背包问题，只不过题目的背景稍微变了一下。
我们先用二维dp来做一下0_1背包问题，首先需要知道“我是谁”，即问题的状态，我们设一个dp数组dp[m+1][t+1],dp[i][j]表示以j为总时间采摘第i个物品所能得到的最大价值。
另外设两个数组tim[m+1],val[m+1],tim[i]和val[i]分别代表第i种草药的采摘时间和它的价值。


首先，当时间为0或者草药价值为0时结果肯定是0，所以我们对数组初始化一波：
```
    int dp[m+1][t+1];
    for(int i=0;i<=m;++i){
        dp[i][0]=0;
    }
    for(int i=0;i<=t;++i){
        dp[0][i]=0;
    }
```

把边界情况考虑清楚，能够让后面的思路更加清晰。  

然后我们考虑状态转移方程，你想一下哈，当来到第i个物品时，你想不想把它装进去，不要贪一点小便宜，我们要以大局为重，该不该装进去？我们要权衡利弊。 如果装进去，那总时间就变成了j-tim[i],dp[i][j]=dp[i-1][j-tim[i]]+val[i], 如果不装进去，那还是上一级状态，即dp[i][j]=dp[i-1][j]. 这个挺好理解吧。

到这儿，这道道题基本上就结束了。确实没有想象中的那么难，好吧，虽然这只是一道入门题，但是体会它的思想你就能获得比题目本身更多的东西。

代码就这样：
```
 #include<bits/stdc++.h>
 using namespace std;
 int main(){
     int t,m;
     scanf("%d%d",&t,&m);
     int tim[m+1],val[m+1];
     for(int i=1;i<=m;++i){
        scanf("%d%d",&tim[i],&val[i]);
     }
     int dp[m+1][t+1];
     for(int i=0;i<=m;++i){
         dp[i][0]=0;
     }
     for(int i=0;i<=t;++i){
         dp[0][i]=0;
     }
     for(int i=1;i<=m;++i){
         for(int j=1;j<=t;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=tim[i]){
                dp[i][j]=max(dp[i][j],val[i]+dp[i-1][j-tim[i]];
            }
            //注意这儿，为什么要有j>=time[i]的条件，因为如果剩余时间不够采摘第i个草药的话，那肯定就没戏。
         }
     }
     cout<<dp[m][t];
     system("pause");
 }
```

>当然，对于上面这种解法空间复杂度是m*t，我们还可以将其压缩，即创建一个一维数组dp[t+1],为什么会想到这种解法，通过上面的状态转移方程，我们知道dp[i][j]是由dp[i-1][j]和dp[i-1][j-val[i]]这2个状态递推得到，事实上，我们可以根据此对其进行空间上的压缩。

 这要求我们在每次主循环中以j：t->0的递减顺序计算dp[j],这样才能保证计算dp[j]时dp[j-val[i]]中存放的是状态dp[i-1][j-val[i]]的值。事实上，这一点你暂时不明白也没关系，这属于后边完全背包的范畴。

```
    for(int i=1;i<=m;++i){
        for(int j=t;j>=1;--j){
            if(j>=w[i]){
                dp[j]=max(dp[j],val[i]+dp[j-tim[i]]);
            }
        }
    }
```
其中dp[j]=max(dp[j],val[i]+dp[j-tim[i]])对应着我们原来的状态转移方程，现在的dp[j-tim[i]]就对应着原来的dp[i-1][j-tim[i]]。

    ```
    #include<bits/stdc++.h>
    using namespace std;
    int main(){
        int t,m;
        scanf("%d%d",&t,&m);
        int w[m+1],val[m+1];
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&w[i],&val[i]);
        }
        int dp[t+1];
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=m;++i){
            for(int j=t;j>=1;--j){
                if(j>=w[i]){
                    dp[j]=max(dp[j],val[i]+dp[j-w[i]]);
                }
            }
        }
        cout<<dp[t];
        system("pause");
    }

如上。