>最大子段和问题。给定由n个整数组成的序列，求序列中子段的最大和，若所有整数均为负整数时定义最大子段和为0。
>
>输入格式:
>第一行输入整数个数n（1≤n≤1000），再依次输入n个整数。
>
>输出格式:
>输出最大子段和。
>
>输入样例1:
>>5
>>-2 11 -4 13 -5 -2
> 
>输出样例1:
>>20
>



>题目的要求是求出一段序列的最大子段和，对于这么一个问题，我们可以采用分治的思想来完成。为什么要采用分支的思想来完成? 当然，我们可以先尝试暴力枚举：枚举所有的起始下标，枚举所有的终止下标，迭代计算并更新最大值，这样的时间复杂度是O(n^3),似乎有些不尽人意，虽然优化后能够达到O(n^2)的复杂度，但是我们想要更快的算法，那么有没有这种可能呢?

>首先回顾一下分治法的三个步骤：
>*1.拆分原问题*
>*2.求解子问题*
>*3.合并问题解*
>对于这个问题，我们可以把数组拆分成两部分，计算左边的最大子数组s1，计算右边的最大子数组s2，然后合并计算跨终点的最大子数组s3，其中的最大值就是我们想要的结果。也就是代码中MaxSubArray部分的思想。

>分解后两边的最大值比较容易得到，重要的是找到合并时跨中点的那个最大值。我们从中间位置开始，设置两个变量left和right记录从中点开始左边的最大值和右边的最大值 (为了防止都是负数得不到想要的值，我们将left和right设置为负无穷)，然后从中点向两边遍历得到两个最大值，又因为它们都跨终点，所以它们相加就是s3的值。整体时间复杂度为O(logn)。代码部分见CrossingSubArray函数。

>此题解题的关键在于合并部分的巧妙优化，有些分治问题的解决是靠合并问题的巧妙，也有些问题是靠拆分问题的巧妙。本题代码如下：

@import "max_sub_array.cpp"
